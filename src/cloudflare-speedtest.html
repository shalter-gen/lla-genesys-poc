<body>
    <div id="controls"></div>
    <div id="speed-check-result"></div>
    <div id="browser-check-result"></div> <!-- Element to display browser check result -->

    <!-- Include Bowser library from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/bowser@2.11.0/es5.js"></script>

    <script type="module">
        import SpeedTest from 'https://cdn.skypack.dev/@cloudflare/speedtest';
        // import Bowser from 'https://cdn.jsdelivr.net/npm/bowser@2.11.0/es5.js';

        const controlEl = document.getElementById('controls');
        const resEl = document.getElementById('speed-check-result');

        // See https://github.com/cloudflare/speedtest        
        const engine = new SpeedTest({
            autoStart: false,
            turnServerUri: 'global.turn.twilio.com:3478',   // https://www.twilio.com/docs/stun-turn/api
            turnServerUser: "bcc6ecd4b8aa85de8b5bd18890fcb716577cc3a2e04828203ba56128bb914c2c", // https://console.twilio.com/?frameUrl=%2Fconsole%3Fx-target-region%3Dus1
            turnServerPass: "tcpEWCWCZi7HcE431P+lZaK42jVzHQqk5/tCvBfEx4o=",
            _measurements: [
                { type: 'latency', numPackets: 1 }, // initial latency estimation
                { type: 'download', bytes: 1e5, count: 1, bypassMinDuration: true }, // initial download estimation
                { type: 'latency', numPackets: 50 },
                //{ type: 'packetLoss', numPackets: 1e3, responsesWaitTime: 1000 },
                { type: 'download', bytes: 1e7, count: 1 },
                { type: 'upload', bytes: 1e5, count: 2 },
            ],
            measurements: [
                { type: 'latency', numPackets: 1 }, // initial latency estimation
                { type: 'download', bytes: 1e5, count: 1, bypassMinDuration: true }, // initial download estimation
                { type: 'packetLoss', numPackets: 1e3, responsesWaitTime: 1000 },
                //{ type: 'download', bytes: 1e7, count: 1 },
                { type: 'latency', numPackets: 50 },
                { type: 'upload', bytes: 5e5, count: 1 },
                { type: 'download', bytes: 5e7, count: 2 },
            ],
            _defaultMeasurements: [
                { type: 'latency', numPackets: 1 }, // initial latency estimation
                { type: 'download', bytes: 1e5, count: 1, bypassMinDuration: true }, // initial download estimation
                { type: 'latency', numPackets: 20 },
                { type: 'download', bytes: 1e5, count: 9 },
                { type: 'download', bytes: 1e6, count: 8 },
                { type: 'upload', bytes: 1e5, count: 8 },
                { type: 'packetLoss', numPackets: 1e3, responsesWaitTime: 3000 },
                { type: 'upload', bytes: 1e6, count: 6 },
                { type: 'download', bytes: 1e7, count: 6 },
                { type: 'upload', bytes: 1e7, count: 4 },
                { type: 'download', bytes: 2.5e7, count: 4 },
                { type: 'upload', bytes: 2.5e7, count: 4 },
                { type: 'download', bytes: 1e8, count: 3 },
                { type: 'upload', bytes: 5e7, count: 3 },
                { type: 'download', bytes: 2.5e8, count: 2 }
            ]
        });
        engine.onRunningChange = running => controlEl.textContent = running ? 'Running...' : 'Finished!';
        engine.onResultsChange = ({ type }) => {
            !engine.isFinished && setResult(engine.results.raw);
            console.log(type + ' finished at ' + new Date());
            // console.log(engine.results.raw);
        };
        engine.onFinish = results => {
            const testDuration = (new Date() - startTime) / 1000;
            setResult({
                TotalTime: testDuration,
                Summary: results.getSummary(),
                Scores: results.getScores(),
                UnloadedLatency: results.getUnloadedLatency(),
                UnloadedJitter: results.getUnloadedJitter(),
                //UnloadedLatencyPoints: results.getUnloadedLatencyPoints(),
                DownLoadedLatency: results.getDownLoadedLatency(),
                DownLoadedJitter: results.getDownLoadedJitter(),
                //DownLoadedLatencyPoints: results.getDownLoadedLatencyPoints(),
                UpLoadedLatency: results.getUpLoadedLatency(),
                UpLoadedJitter: results.getUpLoadedJitter(),
                //UpLoadedLatencyPoints: results.getUpLoadedLatencyPoints(),
                DownloadBandwidth: results.getDownloadBandwidth(),
                //DownloadBandwidthPoints: results.getDownloadBandwidthPoints(),
                UploadBandwidth: results.getUploadBandwidth(),
                //UploadBandwidthPoints: results.getUploadBandwidthPoints(),
                PacketLoss: results.getPacketLoss(),
                PacketLossDetails: results.getPacketLossDetails(),
            });

            console.log(results.getSummary());
            console.log(results.getScores());
        };

        engine.onError = (e) => console.error(e);

        const playButton = document.createElement('button');
        playButton.textContent = "Start Speed Measurement";
        playButton.onclick = () => engine.play();
        //add a variable with current date-time
        const startTime = new Date();
        controlEl.appendChild(playButton);

        function setResult(obj) {
            const resTxt = document.createElement('pre');
            resTxt.textContent = JSON.stringify(obj, null, 2);
            resEl.textContent = '';
            resEl.appendChild(resTxt);
        }

        // Create Check Browser button
        const checkBrowserButton = document.createElement('button');
        checkBrowserButton.textContent = "Check Browser";
        checkBrowserButton.onclick = () => checkBrowser();
        controlEl.appendChild(checkBrowserButton);

        async function fetchLatestVersion(url) {
            const response = await fetch(url);
            return response.text();
        }

        async function checkBrowser() {
            const browser = bowser.getParser(window.navigator.userAgent);
            const browserInfo = browser.getBrowser();
            const browserName = browserInfo.name;
            const browserVersion = parseInt(browserInfo.version, 10);

            let result;
            try {
                if (browserName === 'Safari') {
                    result = 'Fail: Safari is not allowed.';
                } else if (browserName === 'Chrome' || browserName === 'Chromium') {
                    const latestChromeVersion = await fetchLatestVersion('https://chromedriver.storage.googleapis.com/LATEST_RELEASE');
                    result = (browserVersion >= parseInt(latestChromeVersion, 10) - 2) ? 'OK: Chrome is allowed.' : 'Fail: Chrome version is too old.';
                } else if (browserName === 'Edge') {
                    const latestEdgeVersion = await fetchLatestVersion('https://msedgedriver.azureedge.net/LATEST_STABLE');
                    result = (browserVersion >= parseInt(latestEdgeVersion, 10) - 2) ? 'OK: Edge is allowed.' : 'Fail: Edge version is too old.';
                } else {
                    result = 'Fail: Unsupported browser.';
                }
            } catch (error) {
                result = 'Error fetching latest browser version.';
                console.error(error);
            }
            // Display result on the page
            browserCheckResultEl.textContent = result;

            // alert(result);
        }
    </script>
</body>